// Generated by BitPacker
const VERSION = "1.0.2";

const Endian = {
    Big: 0,
    Little: 1,
};

class ZeroCopyByteBuff {
    constructor(dataOrSize = 65536) {
        if (typeof dataOrSize === 'number') {
            this.writeBuf = new Uint8Array(dataOrSize);
            this.cursor = 0;
            this.multiplier = 10000.0;
        } else { // Uint8Array or Buffer
            this.writeBuf = dataOrSize;
            this.cursor = 0;
            this.multiplier = 10000.0;
        }
        this.textEncoder = new TextEncoder();
        this.textDecoder = new TextDecoder();
    }

    ensureCapacity(needed) {
        if (this.cursor + needed > this.writeBuf.length) {
            const newSize = Math.max(this.writeBuf.length * 2, this.cursor + needed);
            const newBuf = new Uint8Array(newSize);
            newBuf.set(this.writeBuf);
            this.writeBuf = newBuf;
        }
    }

    // ZigZag 32
    static zigzagEncode32(n) {
        return (n << 1) ^ (n >> 31);
    }
    static zigzagDecode32(n) {
        return (n >>> 1) ^ -(n & 1);
    }
    
    // VarInt32
    putVarInt32(value) {
        this.ensureCapacity(5);
        // value is treated as 32-bit signed in bitwise ops
        while ((value & ~0x7F) !== 0) {
            this.writeBuf[this.cursor++] = (value & 0x7F) | 0x80;
            value >>>= 7;
        }
        this.writeBuf[this.cursor++] = value;
    }

    getVarInt32() {
        let result = 0;
        let shift = 0;
        while (true) {
            const byte = this.writeBuf[this.cursor++];
            result |= (byte & 0x7F) << shift;
            if ((byte & 0x80) === 0) break;
            shift += 7;
        }
        return result >>> 0; // unsigned
    }

    putInt32(val) {
        this.putVarInt32(ZeroCopyByteBuff.zigzagEncode32(val));
    }

    getInt32() {
        const val = this.getVarInt32();
        return ZeroCopyByteBuff.zigzagDecode32(val);
    }

    // 64-bit VarInt (using BigInt for full precision)
    putVarInt64(val) {
        // Only safe if val is BigInt or safe integer
        // Force BigInt
        let v = BigInt(val); 
        this.ensureCapacity(10);
        // ZigZag 64: (n << 1) ^ (n >> 63)
        let zz = (v << 1n) ^ (v >> 63n);
        
        while ((zz & ~0x7Fn) !== 0n) {
            this.writeBuf[this.cursor++] = Number((zz & 0x7Fn) | 0x80n);
            zz >>= 7n;
        }
        this.writeBuf[this.cursor++] = Number(zz);
    }

    getVarInt64() {
        let result = 0n;
        let shift = 0n;
        while (true) {
            const byte = this.writeBuf[this.cursor++];
            result |= BigInt(byte & 0x7F) << shift;
            if ((byte & 0x80) === 0) break;
            shift += 7n;
        }
        // ZigZag Decode 64: (n >>> 1) ^ -(n & 1)
        return (result >> 1n) ^ -(result & 1n);
    }

	putInt64(val) {
        this.putVarInt64(val);
    }

    getInt64() {
        return this.getVarInt64();
    }

    putFloat(val) {
       // Multiply by scalar and store as int64
       const scaled = BigInt(Math.round(val * this.multiplier));
       this.putVarInt64(scaled);
    }

    getFloat() {
       const val = this.getVarInt64();
       return Number(val) / this.multiplier;
    }

    putBoolean(val) {
        this.ensureCapacity(1);
        this.writeBuf[this.cursor++] = val ? 1 : 0;
    }
    
    getBoolean() {
        return this.writeBuf[this.cursor++] !== 0;
    }

    putString(val) {
        const bytes = this.textEncoder.encode(val);
        this.putInt32(bytes.length);
        this.ensureCapacity(bytes.length);
        this.writeBuf.set(bytes, this.cursor);
        this.cursor += bytes.length;
    }

    getString() {
        const len = this.getInt32();
        if (len === 0) return "";
        const bytes = this.writeBuf.subarray(this.cursor, this.cursor + len);
        this.cursor += len;
        // TextDecoder handles Uint8Array view correctly
        return this.textDecoder.decode(bytes);
    }

    finish() {
        return this.writeBuf.subarray(0, this.cursor);
    }
}


class Player {
constructor() {
	
	this.username = "";
	
	this.level = 0;
	
	this.score = 0;
	
	this.inventory = [];
	
}

encode() {
	const buf = new ZeroCopyByteBuff(65536);
	buf.putString(VERSION);
	this.encodeTo(buf);
	return buf.finish();
}

encodeTo(buf) {
	
	
	buf.putString(this.username);
	
	
	
	buf.putInt32(this.level);
	
	
	
	buf.putInt32(this.score);
	
	
	
	buf.putInt32(this.inventory.length);
	for (let i = 0; i < this.inventory.length; i++) {
        const item = this.inventory[i];
		buf.putString(item);
	}
	
	
}

static decode(data) {
	// 0 check for Endianness
	const buf = new ZeroCopyByteBuff(data);
	const version = buf.getString();
	if (version !== VERSION) {
		throw new Error("Version Mismatch: Expected " + VERSION + ", got " + version);
	}
	return this.decodeFrom(buf);
}

static decodeFrom(buf) {
	const obj = new Player();
	// explicit field order
	
	
	obj.username = buf.getString();
	
	
	
	obj.level = buf.getInt32();
	
	
	
	obj.score = buf.getInt32();
	
	
	
	const inventory_len = buf.getInt32();
	obj.inventory = new Array(inventory_len);
	for (let i = 0; i < inventory_len; i++) {
		obj.inventory[i] = buf.getString();
	}
	
	
	return obj;
}
}

class GameState {
constructor() {
	
	this.id = 0;
	
	this.isActive = false;
	
	this.players = [];
	
}

encode() {
	const buf = new ZeroCopyByteBuff(65536);
	buf.putString(VERSION);
	this.encodeTo(buf);
	return buf.finish();
}

encodeTo(buf) {
	
	
	buf.putInt32(this.id);
	
	
	
	buf.putBoolean(this.isActive);
	
	
	
	buf.putInt32(this.players.length);
	for (let i = 0; i < this.players.length; i++) {
        const item = this.players[i];
		item.encodeTo(buf);
	}
	
	
}

static decode(data) {
	// 0 check for Endianness
	const buf = new ZeroCopyByteBuff(data);
	const version = buf.getString();
	if (version !== VERSION) {
		throw new Error("Version Mismatch: Expected " + VERSION + ", got " + version);
	}
	return this.decodeFrom(buf);
}

static decodeFrom(buf) {
	const obj = new GameState();
	// explicit field order
	
	
	obj.id = buf.getInt32();
	
	
	
	obj.isActive = buf.getBoolean();
	
	
	
	const players_len = buf.getInt32();
	obj.players = new Array(players_len);
	for (let i = 0; i < players_len; i++) {
		obj.players[i] = Player.decodeFrom(buf);
	}
	
	
	return obj;
}
}


module.exports = {
	Endian,
	ZeroCopyByteBuff,
    Player,
    GameState,

};
