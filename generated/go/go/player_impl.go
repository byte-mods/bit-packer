// Generated by BitPacker
package bitpacker

import (
	"errors"
)

const VERSION = "1.0.2"

// --- ZeroCopyByteBuff ---

type ZeroCopyByteBuff struct {
	buf    []byte
	offset int
}

func NewZeroCopyByteBuff(capacity int) *ZeroCopyByteBuff {
	return &ZeroCopyByteBuff{
		buf:    make([]byte, 0, capacity),
		offset: 0,
	}
}

func NewReader(data []byte) *ZeroCopyByteBuff {
	return &ZeroCopyByteBuff{
		buf:    data,
		offset: 0,
	}
}

func (b *ZeroCopyByteBuff) Bytes() []byte {
	return b.buf
}

// ZigZag helpers
func zigzagEncode32(n int32) uint32 { return uint32((n << 1) ^ (n >> 31)) }
func zigzagDecode32(n uint32) int32 { return int32(n>>1) ^ -int32(n&1) }
func zigzagEncode64(n int64) uint64 { return uint64((n << 1) ^ (n >> 63)) }
func zigzagDecode64(n uint64) int64 { return int64(n>>1) ^ -int64(n&1) }

// Write Helpers

func (b *ZeroCopyByteBuff) PutInt32(v int32) {
	b.putVarUint64(uint64(zigzagEncode32(v)))
}

func (b *ZeroCopyByteBuff) PutInt64(v int64) {
	b.putVarUint64(zigzagEncode64(v))
}

func (b *ZeroCopyByteBuff) PutVarInt64(v int64) {
	b.putVarUint64(zigzagEncode64(v))
}

func (b *ZeroCopyByteBuff) putVarUint64(v uint64) {
	// FAST PATH: 1 byte (covers 0-127, most common for game data)
	if v < 0x80 {
		b.buf = append(b.buf, byte(v))
		return
	}
	// FAST PATH: 2 bytes (covers 128-16383)
	if v < 0x4000 {
		b.buf = append(b.buf, byte((v&0x7F)|0x80), byte(v>>7))
		return
	}
	// General path
	for v >= 0x80 {
		b.buf = append(b.buf, byte(v&0x7F)|0x80)
		v >>= 7
	}
	b.buf = append(b.buf, byte(v))
}

func (b *ZeroCopyByteBuff) PutFloat32(v float32) {
	// Multiply by 10000.0 and truncate
	b.PutVarInt64(int64(v * 10000.0))
}

func (b *ZeroCopyByteBuff) PutFloat64(v float64) {
	b.PutVarInt64(int64(v * 10000.0))
}

func (b *ZeroCopyByteBuff) PutBool(v bool) {
	if v {
		b.buf = append(b.buf, 1)
	} else {
		b.buf = append(b.buf, 0)
	}
}

func (b *ZeroCopyByteBuff) PutString(v string) {
    // Length followed by bytes
	b.PutVarInt64(int64(len(v)))
	b.buf = append(b.buf, v...)
}

// Read Helpers

func (b *ZeroCopyByteBuff) getVarUint64() (uint64, error) {
	var result uint64
	var shift uint
	for {
		if b.offset >= len(b.buf) {
			return 0, errors.New("buffer underflow")
		}
		byt := b.buf[b.offset]
		b.offset++
		result |= uint64(byt&0x7F) << shift
		if byt&0x80 == 0 {
			break
		}
		shift += 7
	}
	return result, nil
}

func (b *ZeroCopyByteBuff) GetInt32() (int32, error) {
	v, err := b.getVarUint64()
	if err != nil { return 0, err }
	return zigzagDecode32(uint32(v)), nil
}

func (b *ZeroCopyByteBuff) GetInt64() (int64, error) {
	v, err := b.getVarUint64()
	if err != nil { return 0, err }
	return zigzagDecode64(v), nil
}

func (b *ZeroCopyByteBuff) GetVarInt64() (int64, error) {
	v, err := b.getVarUint64()
	if err != nil { return 0, err }
	return zigzagDecode64(v), nil
}

func (b *ZeroCopyByteBuff) GetFloat32() (float32, error) {
	v, err := b.GetVarInt64()
	return float32(v) / 10000.0, err
}

func (b *ZeroCopyByteBuff) GetFloat64() (float64, error) {
	v, err := b.GetVarInt64()
	return float64(v) / 10000.0, err
}

func (b *ZeroCopyByteBuff) GetBool() (bool, error) {
	if b.offset >= len(b.buf) {
		return false, errors.New("buffer underflow")
	}
	v := b.buf[b.offset]
	b.offset++
	return v != 0, nil
}

func (b *ZeroCopyByteBuff) GetString() (string, error) {
	l, err := b.GetVarInt64()
	if err != nil {
		return "", err
	}
	length := int(l)
	if b.offset+length > len(b.buf) {
		return "", errors.New("buffer underflow")
	}
	s := string(b.buf[b.offset : b.offset+length])
	b.offset += length
	return s, nil
}


func (o *Player) Encode() []byte {
	buf := NewZeroCopyByteBuff(65536)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Player) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutString(o.Username)
	
	
	
	buf.PutInt32(o.Level)
	
	
	
	buf.PutInt32(o.Score)
	
	
	
	buf.PutInt32(int32(len(o.Inventory)))
	for _, item := range o.Inventory {
		buf.PutString(item)
	}
	
	
}

func DecodePlayer(data []byte) (*Player, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodePlayerFrom(buf)
}

func DecodePlayerFrom(buf *ZeroCopyByteBuff) (*Player, error) {
	o := &Player{}
	var err error
	
	
	o.Username, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	o.Level, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Score, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	inventoryLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Inventory = make([]string, inventoryLen)
	for i := 0; i < int(inventoryLen); i++ {
		o.Inventory[i], err = buf.GetString(); if err != nil { return nil, err }
	}
	
	
	return o, nil
}

func (o *GameState) Encode() []byte {
	buf := NewZeroCopyByteBuff(65536)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *GameState) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutInt32(o.Id)
	
	
	
	buf.PutBool(o.IsActive)
	
	
	
	buf.PutInt32(int32(len(o.Players)))
	for _, item := range o.Players {
		item.EncodeTo(buf)
	}
	
	
}

func DecodeGameState(data []byte) (*GameState, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeGameStateFrom(buf)
}

func DecodeGameStateFrom(buf *ZeroCopyByteBuff) (*GameState, error) {
	o := &GameState{}
	var err error
	
	
	o.Id, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.IsActive, err = buf.GetBool(); if err != nil { return nil, err }
	
	
	
	playersLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Players = make([]Player, playersLen)
	for i := 0; i < int(playersLen); i++ {
		Val, err := DecodePlayerFrom(buf); if err != nil { return nil, err }; o.Players[i] = *Val
	}
	
	
	return o, nil
}

