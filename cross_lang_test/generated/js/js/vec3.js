// Generated by BitPacker
const VERSION = "1.0.0";

const Endian = {
    Big: 0,
    Little: 1,
};

class ZeroCopyByteBuff {
    constructor(dataOrSize = 65536) {
        if (typeof dataOrSize === 'number') {
            this.writeBuf = new Uint8Array(dataOrSize);
            this.cursor = 0;
            this.multiplier = 10000.0;
        } else { // Uint8Array or Buffer
            this.writeBuf = dataOrSize;
            this.cursor = 0;
            this.multiplier = 10000.0;
        }
        this.textEncoder = new TextEncoder();
        this.textDecoder = new TextDecoder();
    }

    ensureCapacity(needed) {
        if (this.cursor + needed > this.writeBuf.length) {
            const newSize = Math.max(this.writeBuf.length * 2, this.cursor + needed);
            const newBuf = new Uint8Array(newSize);
            newBuf.set(this.writeBuf);
            this.writeBuf = newBuf;
        }
    }

    // ZigZag 32
    static zigzagEncode32(n) {
        return (n << 1) ^ (n >> 31);
    }
    static zigzagDecode32(n) {
        return (n >>> 1) ^ -(n & 1);
    }
    
    // VarInt32
    putVarInt32(value) {
        this.ensureCapacity(5);
        // value is treated as 32-bit signed in bitwise ops
        while ((value & ~0x7F) !== 0) {
            this.writeBuf[this.cursor++] = (value & 0x7F) | 0x80;
            value >>>= 7;
        }
        this.writeBuf[this.cursor++] = value;
    }

    getVarInt32() {
        let result = 0;
        let shift = 0;
        while (true) {
            const byte = this.writeBuf[this.cursor++];
            result |= (byte & 0x7F) << shift;
            if ((byte & 0x80) === 0) break;
            shift += 7;
        }
        return result >>> 0; // unsigned
    }

    putInt32(val) {
        this.putVarInt32(ZeroCopyByteBuff.zigzagEncode32(val));
    }

    getInt32() {
        const val = this.getVarInt32();
        return ZeroCopyByteBuff.zigzagDecode32(val);
    }

    // 64-bit VarInt (using BigInt for full precision)
    putVarInt64(val) {
        // Only safe if val is BigInt or safe integer
        // Force BigInt
        let v = BigInt(val); 
        this.ensureCapacity(10);
        // ZigZag 64: (n << 1) ^ (n >> 63)
        let zz = (v << 1n) ^ (v >> 63n);
        
        while ((zz & ~0x7Fn) !== 0n) {
            this.writeBuf[this.cursor++] = Number((zz & 0x7Fn) | 0x80n);
            zz >>= 7n;
        }
        this.writeBuf[this.cursor++] = Number(zz);
    }

    getVarInt64() {
        let result = 0n;
        let shift = 0n;
        while (true) {
            const byte = this.writeBuf[this.cursor++];
            result |= BigInt(byte & 0x7F) << shift;
            if ((byte & 0x80) === 0) break;
            shift += 7n;
        }
        // ZigZag Decode 64: (n >>> 1) ^ -(n & 1)
        return (result >> 1n) ^ -(result & 1n);
    }

	putInt64(val) {
        this.putVarInt64(val);
    }

    getInt64() {
        return this.getVarInt64();
    }

    putFloat(val) {
       // Multiply by scalar and store as int64
       const scaled = BigInt(Math.round(val * this.multiplier));
       this.putVarInt64(scaled);
    }

    getFloat() {
       const val = this.getVarInt64();
       return Number(val) / this.multiplier;
    }

    putBoolean(val) {
        this.ensureCapacity(1);
        this.writeBuf[this.cursor++] = val ? 1 : 0;
    }
    
    getBoolean() {
        return this.writeBuf[this.cursor++] !== 0;
    }

    putString(val) {
        const bytes = this.textEncoder.encode(val);
        this.putInt32(bytes.length);
        this.ensureCapacity(bytes.length);
        this.writeBuf.set(bytes, this.cursor);
        this.cursor += bytes.length;
    }

    getString() {
        const len = this.getInt32();
        if (len === 0) return "";
        const bytes = this.writeBuf.subarray(this.cursor, this.cursor + len);
        this.cursor += len;
        // TextDecoder handles Uint8Array view correctly
        return this.textDecoder.decode(bytes);
    }

    finish() {
        return this.writeBuf.subarray(0, this.cursor);
    }
}


class Vec3 {
constructor() {
	
	this.x = 0;
	
	this.y = 0;
	
	this.z = 0;
	
}

encode() {
	const buf = new ZeroCopyByteBuff(65536);
	buf.putString(VERSION);
	this.encodeTo(buf);
	return buf.finish();
}

encodeTo(buf) {
	
	
	buf.putInt32(this.x);
	
	
	
	buf.putInt32(this.y);
	
	
	
	buf.putInt32(this.z);
	
	
}

static decode(data) {
	// 0 check for Endianness
	const buf = new ZeroCopyByteBuff(data);
	const version = buf.getString();
	if (version !== VERSION) {
		throw new Error("Version Mismatch: Expected " + VERSION + ", got " + version);
	}
	return this.decodeFrom(buf);
}

static decodeFrom(buf) {
	const obj = new Vec3();
	// explicit field order
	
	
	obj.x = buf.getInt32();
	
	
	
	obj.y = buf.getInt32();
	
	
	
	obj.z = buf.getInt32();
	
	
	return obj;
}
}

class Item {
constructor() {
	
	this.id = 0;
	
	this.name = "";
	
	this.value = 0;
	
	this.weight = 0;
	
	this.rarity = "";
	
}

encode() {
	const buf = new ZeroCopyByteBuff(65536);
	buf.putString(VERSION);
	this.encodeTo(buf);
	return buf.finish();
}

encodeTo(buf) {
	
	
	buf.putInt32(this.id);
	
	
	
	buf.putString(this.name);
	
	
	
	buf.putInt32(this.value);
	
	
	
	buf.putInt32(this.weight);
	
	
	
	buf.putString(this.rarity);
	
	
}

static decode(data) {
	// 0 check for Endianness
	const buf = new ZeroCopyByteBuff(data);
	const version = buf.getString();
	if (version !== VERSION) {
		throw new Error("Version Mismatch: Expected " + VERSION + ", got " + version);
	}
	return this.decodeFrom(buf);
}

static decodeFrom(buf) {
	const obj = new Item();
	// explicit field order
	
	
	obj.id = buf.getInt32();
	
	
	
	obj.name = buf.getString();
	
	
	
	obj.value = buf.getInt32();
	
	
	
	obj.weight = buf.getInt32();
	
	
	
	obj.rarity = buf.getString();
	
	
	return obj;
}
}

class Character {
constructor() {
	
	this.name = "";
	
	this.level = 0;
	
	this.hp = 0;
	
	this.mp = 0;
	
	this.is_alive = false;
	
	this.position = new Vec3();
	
	this.skills = [];
	
	this.inventory = [];
	
}

encode() {
	const buf = new ZeroCopyByteBuff(65536);
	buf.putString(VERSION);
	this.encodeTo(buf);
	return buf.finish();
}

encodeTo(buf) {
	
	
	buf.putString(this.name);
	
	
	
	buf.putInt32(this.level);
	
	
	
	buf.putInt32(this.hp);
	
	
	
	buf.putInt32(this.mp);
	
	
	
	buf.putBoolean(this.is_alive);
	
	
	
	this.position.encodeTo(buf);
	
	
	
	buf.putInt32(this.skills.length);
	for (let i = 0; i < this.skills.length; i++) {
        const item = this.skills[i];
		buf.putInt32(item);
	}
	
	
	
	buf.putInt32(this.inventory.length);
	for (let i = 0; i < this.inventory.length; i++) {
        const item = this.inventory[i];
		item.encodeTo(buf);
	}
	
	
}

static decode(data) {
	// 0 check for Endianness
	const buf = new ZeroCopyByteBuff(data);
	const version = buf.getString();
	if (version !== VERSION) {
		throw new Error("Version Mismatch: Expected " + VERSION + ", got " + version);
	}
	return this.decodeFrom(buf);
}

static decodeFrom(buf) {
	const obj = new Character();
	// explicit field order
	
	
	obj.name = buf.getString();
	
	
	
	obj.level = buf.getInt32();
	
	
	
	obj.hp = buf.getInt32();
	
	
	
	obj.mp = buf.getInt32();
	
	
	
	obj.is_alive = buf.getBoolean();
	
	
	
	obj.position = Vec3.decodeFrom(buf);
	
	
	
	const skills_len = buf.getInt32();
	obj.skills = new Array(skills_len);
	for (let i = 0; i < skills_len; i++) {
		obj.skills[i] = buf.getInt32();
	}
	
	
	
	const inventory_len = buf.getInt32();
	obj.inventory = new Array(inventory_len);
	for (let i = 0; i < inventory_len; i++) {
		obj.inventory[i] = Item.decodeFrom(buf);
	}
	
	
	return obj;
}
}

class Guild {
constructor() {
	
	this.name = "";
	
	this.description = "";
	
	this.members = [];
	
}

encode() {
	const buf = new ZeroCopyByteBuff(65536);
	buf.putString(VERSION);
	this.encodeTo(buf);
	return buf.finish();
}

encodeTo(buf) {
	
	
	buf.putString(this.name);
	
	
	
	buf.putString(this.description);
	
	
	
	buf.putInt32(this.members.length);
	for (let i = 0; i < this.members.length; i++) {
        const item = this.members[i];
		item.encodeTo(buf);
	}
	
	
}

static decode(data) {
	// 0 check for Endianness
	const buf = new ZeroCopyByteBuff(data);
	const version = buf.getString();
	if (version !== VERSION) {
		throw new Error("Version Mismatch: Expected " + VERSION + ", got " + version);
	}
	return this.decodeFrom(buf);
}

static decodeFrom(buf) {
	const obj = new Guild();
	// explicit field order
	
	
	obj.name = buf.getString();
	
	
	
	obj.description = buf.getString();
	
	
	
	const members_len = buf.getInt32();
	obj.members = new Array(members_len);
	for (let i = 0; i < members_len; i++) {
		obj.members[i] = Character.decodeFrom(buf);
	}
	
	
	return obj;
}
}

class WorldState {
constructor() {
	
	this.world_id = 0;
	
	this.seed = "";
	
	this.guilds = [];
	
	this.loot_table = [];
	
}

encode() {
	const buf = new ZeroCopyByteBuff(65536);
	buf.putString(VERSION);
	this.encodeTo(buf);
	return buf.finish();
}

encodeTo(buf) {
	
	
	buf.putInt32(this.world_id);
	
	
	
	buf.putString(this.seed);
	
	
	
	buf.putInt32(this.guilds.length);
	for (let i = 0; i < this.guilds.length; i++) {
        const item = this.guilds[i];
		item.encodeTo(buf);
	}
	
	
	
	buf.putInt32(this.loot_table.length);
	for (let i = 0; i < this.loot_table.length; i++) {
        const item = this.loot_table[i];
		item.encodeTo(buf);
	}
	
	
}

static decode(data) {
	// 0 check for Endianness
	const buf = new ZeroCopyByteBuff(data);
	const version = buf.getString();
	if (version !== VERSION) {
		throw new Error("Version Mismatch: Expected " + VERSION + ", got " + version);
	}
	return this.decodeFrom(buf);
}

static decodeFrom(buf) {
	const obj = new WorldState();
	// explicit field order
	
	
	obj.world_id = buf.getInt32();
	
	
	
	obj.seed = buf.getString();
	
	
	
	const guilds_len = buf.getInt32();
	obj.guilds = new Array(guilds_len);
	for (let i = 0; i < guilds_len; i++) {
		obj.guilds[i] = Guild.decodeFrom(buf);
	}
	
	
	
	const loot_table_len = buf.getInt32();
	obj.loot_table = new Array(loot_table_len);
	for (let i = 0; i < loot_table_len; i++) {
		obj.loot_table[i] = Item.decodeFrom(buf);
	}
	
	
	return obj;
}
}


module.exports = {
	Endian,
	ZeroCopyByteBuff,
    Vec3,
    Item,
    Character,
    Guild,
    WorldState,

};
