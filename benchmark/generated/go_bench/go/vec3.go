// Generated by BitPacker
package bitpacker

import (
	"errors"
)

const VERSION = "1.0.0"

// --- ZeroCopyByteBuff ---

type ZeroCopyByteBuff struct {
	buf    []byte
	offset int
}

func NewZeroCopyByteBuff(capacity int) *ZeroCopyByteBuff {
	return &ZeroCopyByteBuff{
		buf:    make([]byte, 0, capacity),
		offset: 0,
	}
}

func NewReader(data []byte) *ZeroCopyByteBuff {
	return &ZeroCopyByteBuff{
		buf:    data,
		offset: 0,
	}
}

func (b *ZeroCopyByteBuff) Bytes() []byte {
	return b.buf
}

// ZigZag helpers
func zigzagEncode32(n int32) uint32 { return uint32((n << 1) ^ (n >> 31)) }
func zigzagDecode32(n uint32) int32 { return int32(n>>1) ^ -int32(n&1) }
func zigzagEncode64(n int64) uint64 { return uint64((n << 1) ^ (n >> 63)) }
func zigzagDecode64(n uint64) int64 { return int64(n>>1) ^ -int64(n&1) }

// Write Helpers

func (b *ZeroCopyByteBuff) PutInt32(v int32) {
	b.putVarUint64(uint64(zigzagEncode32(v)))
}

func (b *ZeroCopyByteBuff) PutInt64(v int64) {
	b.putVarUint64(zigzagEncode64(v))
}

func (b *ZeroCopyByteBuff) PutVarInt64(v int64) {
	b.putVarUint64(zigzagEncode64(v))
}

func (b *ZeroCopyByteBuff) putVarUint64(v uint64) {
	// FAST PATH: 1 byte (covers 0-127, most common for game data)
	if v < 0x80 {
		b.buf = append(b.buf, byte(v))
		return
	}
	// FAST PATH: 2 bytes (covers 128-16383)
	if v < 0x4000 {
		b.buf = append(b.buf, byte((v&0x7F)|0x80), byte(v>>7))
		return
	}
	// General path
	for v >= 0x80 {
		b.buf = append(b.buf, byte(v&0x7F)|0x80)
		v >>= 7
	}
	b.buf = append(b.buf, byte(v))
}

func (b *ZeroCopyByteBuff) PutFloat32(v float32) {
	// Multiply by 10000.0 and truncate
	b.PutVarInt64(int64(v * 10000.0))
}

func (b *ZeroCopyByteBuff) PutFloat64(v float64) {
	b.PutVarInt64(int64(v * 10000.0))
}

func (b *ZeroCopyByteBuff) PutBool(v bool) {
	if v {
		b.buf = append(b.buf, 1)
	} else {
		b.buf = append(b.buf, 0)
	}
}

func (b *ZeroCopyByteBuff) PutString(v string) {
    // Length followed by bytes
	b.PutVarInt64(int64(len(v)))
	b.buf = append(b.buf, v...)
}

// Read Helpers

func (b *ZeroCopyByteBuff) getVarUint64() (uint64, error) {
	var result uint64
	var shift uint
	for {
		if b.offset >= len(b.buf) {
			return 0, errors.New("buffer underflow")
		}
		byt := b.buf[b.offset]
		b.offset++
		result |= uint64(byt&0x7F) << shift
		if byt&0x80 == 0 {
			break
		}
		shift += 7
	}
	return result, nil
}

func (b *ZeroCopyByteBuff) GetInt32() (int32, error) {
	v, err := b.getVarUint64()
	if err != nil { return 0, err }
	return zigzagDecode32(uint32(v)), nil
}

func (b *ZeroCopyByteBuff) GetInt64() (int64, error) {
	v, err := b.getVarUint64()
	if err != nil { return 0, err }
	return zigzagDecode64(v), nil
}

func (b *ZeroCopyByteBuff) GetVarInt64() (int64, error) {
	v, err := b.getVarUint64()
	if err != nil { return 0, err }
	return zigzagDecode64(v), nil
}

func (b *ZeroCopyByteBuff) GetFloat32() (float32, error) {
	v, err := b.GetVarInt64()
	return float32(v) / 10000.0, err
}

func (b *ZeroCopyByteBuff) GetFloat64() (float64, error) {
	v, err := b.GetVarInt64()
	return float64(v) / 10000.0, err
}

func (b *ZeroCopyByteBuff) GetBool() (bool, error) {
	if b.offset >= len(b.buf) {
		return false, errors.New("buffer underflow")
	}
	v := b.buf[b.offset]
	b.offset++
	return v != 0, nil
}

func (b *ZeroCopyByteBuff) GetString() (string, error) {
	l, err := b.GetVarInt64()
	if err != nil {
		return "", err
	}
	length := int(l)
	if b.offset+length > len(b.buf) {
		return "", errors.New("buffer underflow")
	}
	s := string(b.buf[b.offset : b.offset+length])
	b.offset += length
	return s, nil
}


type Vec3 struct {
	X int32 `json:"x" msgpack:"x"`
	Y int32 `json:"y" msgpack:"y"`
	Z int32 `json:"z" msgpack:"z"`
	
}

type Item struct {
	Id int32 `json:"id" msgpack:"id"`
	Name string `json:"name" msgpack:"name"`
	Value int32 `json:"value" msgpack:"value"`
	Weight int32 `json:"weight" msgpack:"weight"`
	Rarity string `json:"rarity" msgpack:"rarity"`
	
}

type Character struct {
	Name string `json:"name" msgpack:"name"`
	Level int32 `json:"level" msgpack:"level"`
	Hp int32 `json:"hp" msgpack:"hp"`
	Mp int32 `json:"mp" msgpack:"mp"`
	Is_alive bool `json:"is_alive" msgpack:"is_alive"`
	Position Vec3 `json:"position" msgpack:"position"`
	Skills []int32 `json:"skills" msgpack:"skills"`
	Inventory []Item `json:"inventory" msgpack:"inventory"`
	
}

type Guild struct {
	Name string `json:"name" msgpack:"name"`
	Description string `json:"description" msgpack:"description"`
	Members []Character `json:"members" msgpack:"members"`
	
}

type WorldState struct {
	World_id int32 `json:"world_id" msgpack:"world_id"`
	Seed string `json:"seed" msgpack:"seed"`
	Guilds []Guild `json:"guilds" msgpack:"guilds"`
	Loot_table []Item `json:"loot_table" msgpack:"loot_table"`
	
}



func (o *Vec3) Encode() []byte {
	buf := NewZeroCopyByteBuff(65536)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Vec3) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutInt32(o.X)
	
	
	
	buf.PutInt32(o.Y)
	
	
	
	buf.PutInt32(o.Z)
	
	
}

func DecodeVec3(data []byte) (*Vec3, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeVec3From(buf)
}

func DecodeVec3From(buf *ZeroCopyByteBuff) (*Vec3, error) {
	o := &Vec3{}
	var err error
	
	
	o.X, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Y, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Z, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	return o, nil
}

func (o *Item) Encode() []byte {
	buf := NewZeroCopyByteBuff(65536)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Item) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutInt32(o.Id)
	
	
	
	buf.PutString(o.Name)
	
	
	
	buf.PutInt32(o.Value)
	
	
	
	buf.PutInt32(o.Weight)
	
	
	
	buf.PutString(o.Rarity)
	
	
}

func DecodeItem(data []byte) (*Item, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeItemFrom(buf)
}

func DecodeItemFrom(buf *ZeroCopyByteBuff) (*Item, error) {
	o := &Item{}
	var err error
	
	
	o.Id, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Name, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	o.Value, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Weight, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Rarity, err = buf.GetString(); if err != nil { return nil, err }
	
	
	return o, nil
}

func (o *Character) Encode() []byte {
	buf := NewZeroCopyByteBuff(65536)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Character) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutString(o.Name)
	
	
	
	buf.PutInt32(o.Level)
	
	
	
	buf.PutInt32(o.Hp)
	
	
	
	buf.PutInt32(o.Mp)
	
	
	
	buf.PutBool(o.Is_alive)
	
	
	
	o.Position.EncodeTo(buf)
	
	
	
	buf.PutInt32(int32(len(o.Skills)))
	for _, item := range o.Skills {
		buf.PutInt32(item)
	}
	
	
	
	buf.PutInt32(int32(len(o.Inventory)))
	for _, item := range o.Inventory {
		item.EncodeTo(buf)
	}
	
	
}

func DecodeCharacter(data []byte) (*Character, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeCharacterFrom(buf)
}

func DecodeCharacterFrom(buf *ZeroCopyByteBuff) (*Character, error) {
	o := &Character{}
	var err error
	
	
	o.Name, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	o.Level, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Hp, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Mp, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Is_alive, err = buf.GetBool(); if err != nil { return nil, err }
	
	
	
	PositionVal, err := DecodeVec3From(buf); if err != nil { return nil, err }; o.Position = *PositionVal
	
	
	
	skillsLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Skills = make([]int32, skillsLen)
	for i := 0; i < int(skillsLen); i++ {
		o.Skills[i], err = buf.GetInt32(); if err != nil { return nil, err }
	}
	
	
	
	inventoryLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Inventory = make([]Item, inventoryLen)
	for i := 0; i < int(inventoryLen); i++ {
		Val, err := DecodeItemFrom(buf); if err != nil { return nil, err }; o.Inventory[i] = *Val
	}
	
	
	return o, nil
}

func (o *Guild) Encode() []byte {
	buf := NewZeroCopyByteBuff(65536)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Guild) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutString(o.Name)
	
	
	
	buf.PutString(o.Description)
	
	
	
	buf.PutInt32(int32(len(o.Members)))
	for _, item := range o.Members {
		item.EncodeTo(buf)
	}
	
	
}

func DecodeGuild(data []byte) (*Guild, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeGuildFrom(buf)
}

func DecodeGuildFrom(buf *ZeroCopyByteBuff) (*Guild, error) {
	o := &Guild{}
	var err error
	
	
	o.Name, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	o.Description, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	membersLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Members = make([]Character, membersLen)
	for i := 0; i < int(membersLen); i++ {
		Val, err := DecodeCharacterFrom(buf); if err != nil { return nil, err }; o.Members[i] = *Val
	}
	
	
	return o, nil
}

func (o *WorldState) Encode() []byte {
	buf := NewZeroCopyByteBuff(65536)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *WorldState) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutInt32(o.World_id)
	
	
	
	buf.PutString(o.Seed)
	
	
	
	buf.PutInt32(int32(len(o.Guilds)))
	for _, item := range o.Guilds {
		item.EncodeTo(buf)
	}
	
	
	
	buf.PutInt32(int32(len(o.Loot_table)))
	for _, item := range o.Loot_table {
		item.EncodeTo(buf)
	}
	
	
}

func DecodeWorldState(data []byte) (*WorldState, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeWorldStateFrom(buf)
}

func DecodeWorldStateFrom(buf *ZeroCopyByteBuff) (*WorldState, error) {
	o := &WorldState{}
	var err error
	
	
	o.World_id, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Seed, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	guildsLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Guilds = make([]Guild, guildsLen)
	for i := 0; i < int(guildsLen); i++ {
		Val, err := DecodeGuildFrom(buf); if err != nil { return nil, err }; o.Guilds[i] = *Val
	}
	
	
	
	loot_tableLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Loot_table = make([]Item, loot_tableLen)
	for i := 0; i < int(loot_tableLen); i++ {
		Val, err := DecodeItemFrom(buf); if err != nil { return nil, err }; o.Loot_table[i] = *Val
	}
	
	
	return o, nil
}

