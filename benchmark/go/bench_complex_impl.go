// Generated by BitPacker
package main

import (
	"encoding/binary"
	"errors"
)

const VERSION = "1.0.0"

// --- ZeroCopyByteBuff ---

type ZeroCopyByteBuff struct {
	buf    []byte
	offset int
}

func NewZeroCopyByteBuff(capacity int) *ZeroCopyByteBuff {
	return &ZeroCopyByteBuff{
		buf:    make([]byte, 0, capacity),
		offset: 0,
	}
}

func NewReader(data []byte) *ZeroCopyByteBuff {
	return &ZeroCopyByteBuff{
		buf:    data,
		offset: 0,
	}
}

func (b *ZeroCopyByteBuff) Bytes() []byte {
	return b.buf
}

// Write Helpers

func (b *ZeroCopyByteBuff) PutInt32(v int32) {
	b.PutVarInt64(int64(v))
}

func (b *ZeroCopyByteBuff) PutInt64(v int64) {
	b.PutVarInt64(v)
}

func (b *ZeroCopyByteBuff) PutVarInt64(v int64) {
	// ZigZag encoded by binary.PutVarint
	buf := make([]byte, binary.MaxVarintLen64)
	n := binary.PutVarint(buf, v)
	b.buf = append(b.buf, buf[:n]...)
}

func (b *ZeroCopyByteBuff) PutFloat32(v float32) {
	// Multiply by 10000.0 and truncate
	b.PutVarInt64(int64(v * 10000.0))
}

func (b *ZeroCopyByteBuff) PutFloat64(v float64) {
	b.PutVarInt64(int64(v * 10000.0))
}

func (b *ZeroCopyByteBuff) PutBool(v bool) {
	if v {
		b.buf = append(b.buf, 1)
	} else {
		b.buf = append(b.buf, 0)
	}
}

func (b *ZeroCopyByteBuff) PutString(v string) {
    // Length followed by bytes
	b.PutVarInt64(int64(len(v)))
	b.buf = append(b.buf, v...)
}

// Read Helpers

func (b *ZeroCopyByteBuff) GetInt32() (int32, error) {
	v, err := b.GetVarInt64()
	return int32(v), err
}

func (b *ZeroCopyByteBuff) GetInt64() (int64, error) {
	return b.GetVarInt64()
}

func (b *ZeroCopyByteBuff) GetVarInt64() (int64, error) {
	v, n := binary.Varint(b.buf[b.offset:])
	if n <= 0 {
		return 0, errors.New("varint decode error")
	}
	b.offset += n
	return v, nil
}

func (b *ZeroCopyByteBuff) GetFloat32() (float32, error) {
	v, err := b.GetVarInt64()
	return float32(v) / 10000.0, err
}

func (b *ZeroCopyByteBuff) GetFloat64() (float64, error) {
	v, err := b.GetVarInt64()
	return float64(v) / 10000.0, err
}

func (b *ZeroCopyByteBuff) GetBool() (bool, error) {
	if b.offset >= len(b.buf) {
		return false, errors.New("buffer underflow")
	}
	v := b.buf[b.offset]
	b.offset++
	return v != 0, nil
}

func (b *ZeroCopyByteBuff) GetString() (string, error) {
	l, err := b.GetVarInt64()
	if err != nil {
		return "", err
	}
	length := int(l)
	if b.offset+length > len(b.buf) {
		return "", errors.New("buffer underflow")
	}
	s := string(b.buf[b.offset : b.offset+length])
	b.offset += length
	return s, nil
}


func (o *Vec3) Encode() []byte {
	buf := NewZeroCopyByteBuff(1024)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Vec3) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutInt32(o.X)
	
	
	
	buf.PutInt32(o.Y)
	
	
	
	buf.PutInt32(o.Z)
	
	
}

func DecodeVec3(data []byte) (*Vec3, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeVec3From(buf)
}

func DecodeVec3From(buf *ZeroCopyByteBuff) (*Vec3, error) {
	o := &Vec3{}
	var err error
	
	
	o.X, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Y, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Z, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	return o, nil
}

func (o *Item) Encode() []byte {
	buf := NewZeroCopyByteBuff(1024)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Item) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutInt32(o.Id)
	
	
	
	buf.PutString(o.Name)
	
	
	
	buf.PutInt32(o.Value)
	
	
	
	buf.PutInt32(o.Weight)
	
	
	
	buf.PutString(o.Rarity)
	
	
}

func DecodeItem(data []byte) (*Item, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeItemFrom(buf)
}

func DecodeItemFrom(buf *ZeroCopyByteBuff) (*Item, error) {
	o := &Item{}
	var err error
	
	
	o.Id, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Name, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	o.Value, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Weight, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Rarity, err = buf.GetString(); if err != nil { return nil, err }
	
	
	return o, nil
}

func (o *Character) Encode() []byte {
	buf := NewZeroCopyByteBuff(1024)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Character) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutString(o.Name)
	
	
	
	buf.PutInt32(o.Level)
	
	
	
	buf.PutInt32(o.Hp)
	
	
	
	buf.PutInt32(o.Mp)
	
	
	
	buf.PutBool(o.Is_alive)
	
	
	
	o.Position.EncodeTo(buf)
	
	
	
	buf.PutInt32(int32(len(o.Skills)))
	for _, item := range o.Skills {
		buf.PutInt32(item)
	}
	
	
	
	buf.PutInt32(int32(len(o.Inventory)))
	for _, item := range o.Inventory {
		item.EncodeTo(buf)
	}
	
	
}

func DecodeCharacter(data []byte) (*Character, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeCharacterFrom(buf)
}

func DecodeCharacterFrom(buf *ZeroCopyByteBuff) (*Character, error) {
	o := &Character{}
	var err error
	
	
	o.Name, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	o.Level, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Hp, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Mp, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Is_alive, err = buf.GetBool(); if err != nil { return nil, err }
	
	
	
	PositionVal, err := DecodeVec3From(buf); if err != nil { return nil, err }; o.Position = *PositionVal
	
	
	
	skillsLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Skills = make([]int32, skillsLen)
	for i := 0; i < int(skillsLen); i++ {
		o.Skills[i], err = buf.GetInt32(); if err != nil { return nil, err }
	}
	
	
	
	inventoryLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Inventory = make([]Item, inventoryLen)
	for i := 0; i < int(inventoryLen); i++ {
		Val, err := DecodeItemFrom(buf); if err != nil { return nil, err }; o.Inventory[i] = *Val
	}
	
	
	return o, nil
}

func (o *Guild) Encode() []byte {
	buf := NewZeroCopyByteBuff(1024)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *Guild) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutString(o.Name)
	
	
	
	buf.PutString(o.Description)
	
	
	
	buf.PutInt32(int32(len(o.Members)))
	for _, item := range o.Members {
		item.EncodeTo(buf)
	}
	
	
}

func DecodeGuild(data []byte) (*Guild, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeGuildFrom(buf)
}

func DecodeGuildFrom(buf *ZeroCopyByteBuff) (*Guild, error) {
	o := &Guild{}
	var err error
	
	
	o.Name, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	o.Description, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	membersLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Members = make([]Character, membersLen)
	for i := 0; i < int(membersLen); i++ {
		Val, err := DecodeCharacterFrom(buf); if err != nil { return nil, err }; o.Members[i] = *Val
	}
	
	
	return o, nil
}

func (o *WorldState) Encode() []byte {
	buf := NewZeroCopyByteBuff(1024)
	buf.PutString(VERSION)
	o.EncodeTo(buf)
	return buf.Bytes()
}

func (o *WorldState) EncodeTo(buf *ZeroCopyByteBuff) {
	
	
	buf.PutInt32(o.World_id)
	
	
	
	buf.PutString(o.Seed)
	
	
	
	buf.PutInt32(int32(len(o.Guilds)))
	for _, item := range o.Guilds {
		item.EncodeTo(buf)
	}
	
	
	
	buf.PutInt32(int32(len(o.Loot_table)))
	for _, item := range o.Loot_table {
		item.EncodeTo(buf)
	}
	
	
}

func DecodeWorldState(data []byte) (*WorldState, error) {
	buf := NewReader(data)
	version, err := buf.GetString()
	if err != nil { return nil, err }
	if version != VERSION {
		return nil, errors.New("version mismatch")
	}
	return DecodeWorldStateFrom(buf)
}

func DecodeWorldStateFrom(buf *ZeroCopyByteBuff) (*WorldState, error) {
	o := &WorldState{}
	var err error
	
	
	o.World_id, err = buf.GetInt32(); if err != nil { return nil, err }
	
	
	
	o.Seed, err = buf.GetString(); if err != nil { return nil, err }
	
	
	
	guildsLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Guilds = make([]Guild, guildsLen)
	for i := 0; i < int(guildsLen); i++ {
		Val, err := DecodeGuildFrom(buf); if err != nil { return nil, err }; o.Guilds[i] = *Val
	}
	
	
	
	loot_tableLen, err := buf.GetInt32()
	if err != nil { return nil, err }
	o.Loot_table = make([]Item, loot_tableLen)
	for i := 0; i < int(loot_tableLen); i++ {
		Val, err := DecodeItemFrom(buf); if err != nil { return nil, err }; o.Loot_table[i] = *Val
	}
	
	
	return o, nil
}

